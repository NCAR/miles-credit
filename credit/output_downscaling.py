"""
output_downscaling.py
-------------------------------------------------------
Content:
    - OutputWrangler
    - OutputWriter
"""

import os
import yaml
import logging
import traceback
import numpy as np
import xarray as xr

from dataclasses import dataclass, field
from typing import Dict, List

from credit.datamap import VarDict
from credit.data_downscaling import DownscalingDataset

logger = logging.getLogger(__name__)


@dataclass
class OutputWrangler:
    dataset:        DownscalingDataset
    templates:      Dict  # {'dir': path, 'files': {dataset1: file1, dataset2: file2}}
    output_dir:     str
    # save_vars: List[str] = None  # todo: allow yaml to subset output vars

    def __post_init__(self):
        # templates dict has been validated by parser; we can assume its structure is good
        self.output_dir = os.path.expandvars(self.output_dir)
        os.makedirs(self.output_dir, exist_ok=True)

        self.writers = {}
        for dset in self.templates['files']:
            print(dset)
            dmap = self.dataset.datasets[dset]['datamap']
            print(dmap.variables)

            tpath = os.path.join(self.templates['dir'], self.templates['files'][dset])
            
            self.writers[dset] = OutputWriter(
                template_path = tpath,
                variables = dmap.variables,
                dim = dmap.dim,
                zstride = dmap.zstride
            )

    def process(self, y_pred, dates, prefix=None):
        # y_pred is tensor generated by model(x)
        # dates is a Sample['dates'] dict

        hlen = self.dataset.history_len
        
        datadict = self.dataset.revert(y_pred)

        # go with first datetime if forecast_len is > 1
        datestamp = dates['cf_datetimes'][hlen].replace(" ", "_")
        
        outdate = {k: dates[k] for k in ['calendar','units']}
        outdate['time'] = dates['time'][hlen:]
                
        for dset in datadict:
            #outfile = f"{dset}.{datestamp}.nc"
            outfile = ".".join(filter(None, (prefix, dset, datestamp, "nc")))
            outpath = os.path.join(self.output_dir, outfile)
            try:
                self.writers[dset].write(
                    data = datadict[dset],
                    newtime = outdate,
                    output_path = outpath
                )
                
                logger.info(f"Saved prediction to {outfile}")
            except Exception as e:
                print(traceback.format_exc())
                raise e


# OutputWriter class

@dataclass
class OutputWriter:
    template_path: str
    dim:       str = "2D"
    variables: VarDict[str, List] = field(default_factory=list)
    zstride:   int = 1
    noop:      bool = False

    def __post_init__(self):
        # generate list of output variables
        self.outvars = []
        for usage in ("prognostic", "diagnostic"):
            if usage in self.variables:
                self.outvars = self.outvars + self.variables[usage]

        if len(self.outvars) == 0:
            self.noop = True
        else:
            self.noop = False
                        
            # create template xarray object
            self.template = xr.open_dataset(self.template_path, decode_times=False)
            self.template.load()
            self.template.close()
            
            for v in self.template.data_vars:
                if v in self.outvars:
                    if self.dim == "3D" and self.zstride != 0:
                        #todo: subset z-levels
                        pass
                    # this should never matter, but just in case
                    self.template[v][:] = np.nan                    
                else:
                    self.template = self.template.drop(v)

    def write(self, data, newtime, output_path):

        if self.noop:
            pass
        else:
            result = self.template.copy(deep=True, data=data)

            result.coords['time'] = newtime['time']
            result.coords['time'].attrs['units'] = newtime['units']
            result.coords['time'].attrs['calendar'] = newtime['calendar']

            result.to_netcdf(output_path)

